[{"content":"CLion的安装、配置与使用 以及如何对代码进行调试(debug) 1.编译器的安装   Win\nMinGW，点此下载 ，解压密码：hpat\n下载完毕将压缩包内容解压到C盘下（个人习惯，放其他位置也可，但需记住所放位置）  将mingw64解压在根目录 \n  Mac\n终端执行\n   xcode-select --install 2.下载安装Clion  地址：点此下载 下载后正常安装即可 安装后弹出登陆选项，此时需要注册一个教育账号即可激活，点此注册 进入后用教育（中大）邮箱注册 注册后登录激活即可（若注册失败也可尝试使用本人账号激活username:1159292671@qq.com,password:#Xhx0530!）  3.开始使用，运行自己的第一个程序   创建工程\n 选择创建新工程 \n  选择C语言工程，并为工程命名\n \n  进入设置\n \n  选择Toolchains-\u0026gt;MinGW\n \n  若MinGW解压在C盘根目录下，一般将自动识别，若识别失败，也可自己填写所在位置C:\\mingw64（我将MinGW解压在C盘根目录，如果你的不是，按照你的情况改地址即可）\n 成功识别到 \n  保存设置即可运行第一个程序，点击右上角开始按键\n 成功完成输入输出 \n   至此软件配置成功，需要做另一个程序按上述步骤创建运行即可，不必再选择编译器\n 3.如何调试自己的程序   这里给一个样例，点击一下序号右边，会出现小红点（程序断点，表明程序执行到此处将暂停），接着点击运行案件右侧的调试按键。\n 程序运行至第6行停下 \n  可以看见此时下方有变量面板，表示运行到黄色箭头处，当前变量的值为多少（此时a为1，b为107(对应ascii的字符k)）\n  点击下一步按钮，程序走向下一行\n 往前走了两行 \n此时变量相应改变\n 再往前走两行 \n   使用调试器，能极大地帮助我们调试我们的程序，当我们写了Bug，便能够较为轻松地检查错误，并改正，真正做到高效。\n 4. 代码联想与编写时同步提醒 该IDE的一大特点，在你未运行前，能提前告知你可能会出现错误的地方，并给出建议的解决办法，如下图的程序（这里引用一位学弟所编写的代码）\n 发现无论输入什么都无法得到正确值 \n为什么值错了呢？由于C语言是一行一行运行的，未输入前先做运算导致此程序出错。\n 将鼠标放到有黄色提醒的X上 \n告诉你X还未初始化，说明还没有值，这样就能发现自己的代码顺序出问题了吧！\n","date":"2021-03-17T00:00:00Z","image":"https://hungyam.gitee.io/code/p/how-to-use-clion/3_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://hungyam.gitee.io/code/p/how-to-use-clion/","title":"How To Use Clion"},{"content":"MacOS/Win x64 C语言编译器的搭建 Windows x64 MinGW最大的特点就是编译出来的可执行文件能够独立在Windows上运行。\nMinGW的组成：\n 编译器(支持C、C++、ADA和Fortran) GNU工具  1. MinGW安装 MinGW官方网址：http://www.mingw.org/\n由于是墙外网站，经常会出现网站打不开，下载不了的情况，就不详细描述mingw的下载方法。\n这里为读者准备了完整的内容包 点此下载\n下载完毕将压缩包内容解压到C盘下（个人习惯，放其他位置也可，但需记住所放位置）\n2. 添加环境变量  \n  解压后出现mingw64文件夹\n \n  在此电脑上右键选择属性\n \n  左侧选择高级系统设置\n \n  高级页下选择环境变量\n \n  在系统变量栏中双击Path变量\n \n  点击右侧浏览\n \n  找到第一步解压的mingw64下的bin文件夹\n到这里，环境变量已设置完毕\n  3. 测试是否搭建成功  \n  在资源管理器的地址栏中输入cmd，并按回车，打开命令行\n \n  在命令行下键入 gcc -v，若出现版本号，则为搭建成功\n  MacOS 安装及搭建  可直接在App Store中下载Xcode，完成安装即可  （若不想安装整套Xcode开发工具，也可直接在命令行下安装Xcode Command Line Tools）\n \n  应用中选择终端机\n \n  //输入安装命令 xcode-select --install  \n  //查询版本号 xcode-select --version   编译运行自己的第一个程序 这里以VScode为例（适用于MacOS/Win x64）  \n  选择Open folder打开任意一个文件夹（存代码）\n \n  创建一个新文件 文件以 .c 为后缀即可\n \n  这里随便写一段打印功能的代码，写完后**Ctrl+S（win）/Command+S（mac）**保存\n \n  打开一个新终端\n \n  键入gcc 1.c(你的文件名)，执行编译\n  编译完成后运行程序\n  ./a.exe（win 下编译后默认的文件名）\n  ./a.out（mac 下编译后默认的文件名）\n  可见到终端输出 程序中的打印内容\n  MacOS上非常推荐Xcode作主力IDE  \n  选择 Create a new Xcode project\n \n  macOS页下的 Command Line Tool\n \n  随便输入一个工程名字，选择C语言\n \n  选择main.c文件即可进行编辑，创建时会有默认代码\n \n  输入Command+R进行编译运行\n   ","date":"2021-01-23T00:00:00Z","image":"https://hungyam.gitee.io/code/p/gcc/2_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://hungyam.gitee.io/code/p/gcc/","title":"GCC"},{"content":"括号匹配 1.直接对相应的左右括号进行记录，左括号加一，右括号减一，一旦计数出现负数则不匹配（因为不能先出现右括号）\n#include \u0026lt;stdio.h\u0026gt;int main (void){ char c; char ch[60]; int a,b,d; a=b=d=0; while(scanf(\u0026#34;%c\u0026#34;,\u0026amp;c)==1){ switch(c){ case \u0026#39;(\u0026#39;:a++;break; case \u0026#39;)\u0026#39;:a--;break; case \u0026#39;[\u0026#39;:b++;break; case \u0026#39;]\u0026#39;:b--;break; case \u0026#39;{\u0026#39;:d++;break; case \u0026#39;}\u0026#39;:d--;break; } if(a\u0026lt;0||b\u0026lt;0||d\u0026lt;0){ printf(\u0026#34;No\u0026#34;); return 0; } } if(a==0\u0026amp;\u0026amp;b==0\u0026amp;\u0026amp;d==0) printf(\u0026#34;Yes\u0026#34;); else printf(\u0026#34;No\u0026#34;); return 0; } 2.用栈实现。\n​\t遇到左括号，将其压入栈；\n​\t遇到右括号，若栈顶为对应的左括号，则将左括号出栈。\n​\t最后判断栈是否为空，空则匹配。\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;int main() { char a[100]={0}; char stack[100]={0}; scanf(\u0026#34;%s\u0026#34;,a); int len=strlen(a); int k=0; if(a[0]==\u0026#39;{\u0026#39;||a[0]==\u0026#39;}\u0026#39;||a[0]==\u0026#39;[\u0026#39;||a[0]==\u0026#39;]\u0026#39;||a[0]==\u0026#39;(\u0026#39;||a[0]==\u0026#39;)\u0026#39;) { stack[k++]=a[0]; } for(int i=1;i\u0026lt;len;i++) { if(a[i]==\u0026#39;{\u0026#39;||a[i]==\u0026#39;[\u0026#39;||a[i]==\u0026#39;(\u0026#39;) stack[k++]=a[i]; if(a[i]==\u0026#39;}\u0026#39;) { if(stack[k-1]==\u0026#39;{\u0026#39;) stack[--k]=0; else stack[k++]=a[i]; } if(a[i]==\u0026#39;]\u0026#39;) { if(stack[k-1]==\u0026#39;[\u0026#39;) stack[--k]=0; else stack[k++]=a[i]; } if(a[i]==\u0026#39;)\u0026#39;) { if(stack[k-1]==\u0026#39;(\u0026#39;) stack[--k]=0; else stack[k++]=a[i]; } } if(stack[0]==0\u0026amp;\u0026amp;stack[1]==0) printf(\u0026#34;Yes\u0026#34;); else printf(\u0026#34;No\u0026#34;); return 0; } 例如：4+(2+8)*[5/(9-7)]​ 由于栈具有“先进后出”的特点，能很好地表现优先级这个性质，因此可以用栈来存储已经检测到的括号。\n以（A）为例：\n img  img  img \n img  img  img  img \n有以下步骤：\n（1）检测到第一个括号“(”，进栈；\n（2）检测到第二个括号“)”，进栈。子表达式 “4+(2+8)” 完成匹配，匹配的括号都出栈；\n（3）检测到第三个括号“[”，进栈；\n（4）检测到第四个括号“(”，进栈。与（3）中的括号不匹配，但由于同是左括号，可以继续匹配；\n（5）检测到第五个括号“)”，进栈。由括号的作用可知，后来的括号比先来的括号优先级高，因此与（4）中括号匹配，匹配的括号都出栈；\n（6）检测到第六个括号“]”，进栈。由于原来优先级更高的括号已完成，因此与（3）中括号匹配。匹配的括号都出栈，至此所有括号匹配完成。\n","date":"2020-12-01T00:00:00Z","image":"https://hungyam.gitee.io/code/p/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/3_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://hungyam.gitee.io/code/p/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/","title":"括号匹配"},{"content":"We run 长跑周 ➡➡➡活动打卡情况查询入口 ","date":"2020-11-11T00:00:00Z","image":"https://hungyam.gitee.io/code/p/werun_check/640_hu7241423b784c0769a705d913cd64263a_72470_120x120_fill_box_smart1_2.png","permalink":"https://hungyam.gitee.io/code/p/werun_check/","title":"Werun_check"},{"content":"Lab Work 04-1. Application of Stacks Note: Programming in C,\nDesign a C program to implement:\n (1) Arithmetic expression translation: from in-fix to post-fix notation (2) Evaluation of an arithmetic expression in post-fix notation  Solution: #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;string.h\u0026gt;int main(){ char in_fix[20]={0};//中缀  char post_fix[20]={0};//后准  char stack[20]={0};//  int top=0; int index=0; scanf(\u0026#34;%s\u0026#34;,in_fix); /*translation*/ for(int i=0;i\u0026lt;strlen(in_fix);i++){ if(in_fix[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;in_fix[i]\u0026lt;=\u0026#39;9\u0026#39;){ post_fix[index++]=in_fix[i]; }else if(in_fix[i]==\u0026#39;(\u0026#39;){ stack[top++]=\u0026#39;(\u0026#39;; }else if(in_fix[i]==\u0026#39;)\u0026#39;){ while(stack[top-1]!=\u0026#39;(\u0026#39;){ post_fix[index++]=stack[top-1]; top--; } }else if(in_fix[i]==\u0026#39;+\u0026#39;||in_fix[i]==\u0026#39;-\u0026#39;){ if(top){ while(stack[top-1]==\u0026#39;*\u0026#39;||stack[top-1]==\u0026#39;/\u0026#39;){ post_fix[index++]=stack[top-1]; top--; } } stack[top++]=in_fix[i]; }else{ stack[top++]=in_fix[i]; } } while(top){ if(stack[top-1]!=\u0026#39;(\u0026#39;) post_fix[index++]=stack[top-1]; top--; } printf(\u0026#34;The post-fix notation is: %s\\n\u0026#34;,post_fix); /*evaluaion*/ index=0; int eva[20]={0}; for(int i=0;i\u0026lt;strlen(post_fix);i++){ if(post_fix[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;post_fix[i]\u0026lt;=\u0026#39;9\u0026#39;){ eva[top++]=post_fix[i]-48; }else if(post_fix[i]==\u0026#39;+\u0026#39;){ eva[top-2]=eva[top-2]+eva[top-1]; top--; }else if(post_fix[i]==\u0026#39;-\u0026#39;){ eva[top-2]=eva[top-2]-eva[top-1]; top--; }else if(post_fix[i]==\u0026#39;*\u0026#39;){ eva[top-2]=eva[top-2]*eva[top-1]; top--; }else{ eva[top-2]=eva[top-2]/eva[top-1]; top--; } } printf(\u0026#34;Evaluaion: %d\\n\u0026#34;,eva[top-1]); return 0; } Standard I/O input: 2*5-3 output: The post-fix notation is: 25*3- Evaluaion: 7 input: 2*(6+6*3) output: The post-fix notation is: 2663*+* Evaluaion: 48 ","date":"2020-11-10T00:00:00Z","image":"https://hungyam.gitee.io/code/p/%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E5%90%8E%E7%BC%80%E6%B1%82%E8%A7%A3/3_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://hungyam.gitee.io/code/p/%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%E5%90%8E%E7%BC%80%E6%B1%82%E8%A7%A3/","title":"中缀转后缀、后缀求解"},{"content":"题目一：迷宫 制作网页实现下图中的迷宫：\n img \n需求规格   UI：UI与上图完全一致；或者，自由发挥，设计出更加漂亮、合理的UI。\n  正常赢：移动鼠标，从S开始，到E结束，中间不碰墙，赢得游戏，显示“You Win”\n  碰墙输：从S开始后，到E结束之前，碰墙，墙变红，输，显示“You Lose”\n  重置结果：离开迷宫，墙恢复正常；从S开始时，隐藏结果显示\n  发现作弊：如果用户未经过S，就指到E，又或者指向S之后，从迷宫外绕路指向E，显示\u0026quot;Don\u0026rsquo;t cheat, you should start form the \u0026lsquo;S\u0026rsquo; and move to the \u0026lsquo;E\u0026rsquo; inside the maze!\u0026quot;\n迷宫实现网页   题目二：打地鼠 制作网页实现下图中的简版的打地鼠：\n img \n需求规格   UI：UI与上图完全一致；或者，自由发挥，设计出更加漂亮、合理的UI。\n  打地鼠：能够随机出现地鼠，鼠标能够击中（点击正确，地鼠消失，出现新地鼠；点击错误，地鼠不消失）\n  正确计分：正确计算分数并显示，包括正确结束游戏\n打地鼠实现网页   ","date":"2020-10-27T00:00:00Z","image":"https://hungyam.gitee.io/code/p/two-game-by-javascript/2_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://hungyam.gitee.io/code/p/two-game-by-javascript/","title":"Two Game by JavaScript"},{"content":"Mars编程： ​\t先输入12个整数保存起来，再分成两组（5个整数和7个整数），然后把它们分别用选择排序方法进行排序，最后再显示这两个组的数据的排序结果。\n​\t例如：\n​\t输入：20 12 5 6 34 15 4 8 2 6 12 30\n​\t显示：5 6 12 20 34 2 4 6 8 12 15 30\n​\t要求排序用一个具有两个参数(基地址和排序整数个数)的叶过程实现。\n​\t* 选择排序：先利用一个数与其他数比较，找出最大的数，然后在剩余的数中再用同样的方法找最大的，\u0026hellip;\n源代码: .text .globl main main: li $v0, 4 la $a0, msg syscall la $s1, nums move $s0, $zero get: li $v0,5 syscall sll $t0, $s0, 2 add $t1, $s1, $t0 sw $v0, 0($t1) addi $s0, $s0, 1 slti $t2, $s0, 12 bne $t2, $zero, get add $s0, $zero, $zero sort1: add $s2, $zero, $zero #内循环控制变量j  lw $t3, 0($s1) #存最大值  add $s6, $zero, $zero #最大值所在的下标  add $t6, $zero, $zero #临时存数组值 loop1: sll $s3, $s2, 2 add $s4, $s3, $s1 lw $t6, 0($s4) #数组值放进t6  slt $s5, $t3, $t6 beq $s5, $zero ,skip1 #max\u0026lt;t6,赋值  add $t3, $zero ,$t6 #更新最大值  add $s6, $zero ,$s2 #更新最大值所在的index skip1: addi $s2 ,$s2, 1 #j++  addi $t4 ,$zero, 4 sub $t4 ,$t4 ,$s0 #t4=4-i  addi $a3 ,$t4 ,1 slt $t5 ,$s2 ,$a3 bne $t5 ,$zero, loop1 #j\u0026lt;t4  sll $t7, $t4 ,2 add $t8, $s1 ,$t7 lw $a1, 0($t8) sll $t7, $s6 ,2 add $t9, $s1 ,$t7 lw $a2, 0($t9) sw $a1, 0($t9) sw $a2, 0($t8) addi $s0, $s0, 1 slti $t2, $s0, 4 bne $t2, $zero, sort1 add $s0, $zero, $zero add $s1, $s1, 20 sort2: add $s2, $zero, $zero #内循环控制变量j  lw $t3, 0($s1) #存最大值  add $s6, $zero, $zero #最大值所在的下标  add $t6, $zero, $zero #临时存数组值 loop2: sll $s3, $s2, 2 add $s4, $s3, $s1 lw $t6, 0($s4) #数组值放进t6  slt $s5, $t3, $t6 beq $s5, $zero ,skip2 #max\u0026lt;t6,赋值  add $t3, $zero ,$t6 #更新最大值  add $s6, $zero ,$s2 #更新最大值所在的index skip2: addi $s2 ,$s2, 1 #j++  addi $t4 ,$zero, 6 sub $t4 ,$t4 ,$s0 #t4=6-i  addi $a3 ,$t4 ,1 slt $t5 ,$s2 ,$a3 bne $t5 ,$zero, loop2 #j\u0026lt;t4  sll $t7, $t4 ,2 add $t8, $s1 ,$t7 lw $a1, 0($t8) sll $t7, $s6 ,2 add $t9, $s1 ,$t7 lw $a2, 0($t9) sw $a1, 0($t9) sw $a2, 0($t8) addi $s0, $s0, 1 slti $t2, $s0, 6 bne $t2, $zero, sort2 move $s0, $zero la $s1, nums out: sll $t0, $s0, 2 add $t1, $s1, $t0 lw $a0, 0($t1) li $v0, 1 syscall la $a0, seperate li $v0, 4 syscall addi $s0, $s0, 1 slti $t2, $s0, 12 bne $t2, $zero, out li $v0, 10 syscall .data msg: .asciiz \u0026#34;input 12 integers:\\n\u0026#34; .align 2 nums: .word .space 48 seperate: .asciiz \u0026#34; \u0026#34; ","date":"2020-10-27T00:00:00Z","image":"https://hungyam.gitee.io/code/p/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fmips%E6%B1%87%E7%BC%96/3_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://hungyam.gitee.io/code/p/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8Fmips%E6%B1%87%E7%BC%96/","title":"选择排序(mips汇编)"},{"content":"Requirements: Note: Programming in C, Let n be a positive integer with specified initial value n=30. Use an array of n units to store polynomials of one indeterminate (一元多项式). Design and implement a C program to:\n Determine the data structure of the array Use a stack S in the array to store unused units. Initially all the units are unused and the 0 to (n-1) indexes spread randomly on the stack Use two lists LP and LQ in the array to store two polynomials P and Q of one indeterminate Show the map of the array Adding P and Q, restore the result as a list LPQ in the array, and release all garbage units to the stack Show the map of the array again  Solution： ​\t链表的静态实现法，利用数组模拟动态链表，用栈来标记还未使用的节点。\n节点的声明 typedef struct node{ //the list node  int data; int highpower; int next; }Node; 一些变量的声明 Node list[30]={0}; //List_array int head_p=-1; //Head of list LP int head_q=-1; //Head of list LQ int head_sum=-1; //Head of list LPQ int manage_stack[30]={7,24,9,20,16,22,0,18,27,1,23,25,6,13,3,8,21,17,4,11,15,26,5,19,10,28,29,12,2,14}; //Store unused units int top=29; //Top of stack 一元多项式的打印 void print_list(int head){ //Print the polynomials of one indeterminate  while (head!=-1) { if (list[head].highpower\u0026gt;1) printf(\u0026#34;%dx^%d\u0026#34;,list[head].data,list[head].highpower); else if (list[head].highpower==1) printf(\u0026#34;%dx\u0026#34;,list[head].data); else printf(\u0026#34;%d\u0026#34;,list[head].data); if (list[head].next==-1) printf(\u0026#34;\\n\u0026#34;); else if (list[list[head].next].data\u0026gt;=0) printf(\u0026#34;+\u0026#34;); head=list[head].next; } } 储存空间的打印 void print_array(int list1){ //Show the map of the array  printf(\u0026#34;\\nindex\\tdata\\thighpower\\tnext\\n\u0026#34;); int temp=list1; while (temp!=-1) { printf(\u0026#34;%d\\t\\t%d\\t\\t%d\\t\\t\\t%d\\n\u0026#34;,temp,list[temp].data,list[temp].highpower,list[temp].next); temp=list[temp].next; } } 空间管理栈的打印 void print_stack(){ //Show the map of the stack  printf(\u0026#34;\\nStack(from bottom to top):\u0026#34;); for (int i=0; i\u0026lt;=top; i++) { printf(\u0026#34;%d \u0026#34;,manage_stack[i]); } printf(\u0026#34;\\n\u0026#34;); } 一元多项式加法的实现 void add(){ //Adding list P and Q  int temp=-1; while (!(head_p==-1||head_q==-1)) { if (head_sum==-1) { //Determines whether it is the first node  head_sum=manage_stack[top--]; temp=head_sum; }else{ list[temp].next=manage_stack[top--]; temp=list[temp].next; } if (list[head_p].highpower\u0026gt;list[head_q].highpower) { list[temp].data=list[head_p].data; list[temp].highpower=list[head_p].highpower; list[temp].next=-1; manage_stack[++top]=head_p; head_p=list[head_p].next; }else if (list[head_q].highpower\u0026gt;list[head_p].highpower){ list[temp].data=list[head_q].data; list[temp].highpower=list[head_q].highpower; list[temp].next=-1; manage_stack[++top]=head_q; head_q=list[head_q].next; }else{ if(list[head_p].data+list[head_q].data==0){ manage_stack[++top]=head_p; head_p=list[head_p].next; manage_stack[++top]=head_q; head_q=list[head_q].next; manage_stack[++top]=temp; continue; } list[temp].data=list[head_p].data+list[head_q].data; list[temp].highpower=list[head_p].highpower; list[temp].next=-1; manage_stack[++top]=head_p; head_p=list[head_p].next; manage_stack[++top]=head_q; head_q=list[head_q].next; } } } main函数 int main(int argc, const char * argv[]) { int p_num=0; int q_num=0; int data=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;p_num); for (int i=0; i\u0026lt;p_num; i++) { //Input list P  scanf(\u0026#34;%d\u0026#34;,\u0026amp;data); if(!data) continue; list[manage_stack[top]].data=data; list[manage_stack[top]].highpower=i; list[manage_stack[top]].next=head_p; head_p=manage_stack[top--]; } scanf(\u0026#34;%d\u0026#34;,\u0026amp;q_num); for (int i=0; i\u0026lt;q_num; i++) { //Input list Q  scanf(\u0026#34;%d\u0026#34;,\u0026amp;data); if(!data) continue; list[manage_stack[top]].data=data; list[manage_stack[top]].highpower=i; list[manage_stack[top]].next=head_q; head_q=manage_stack[top--]; } printf(\u0026#34;\\n***** the first polynomials of one indeterminate *****\\n\u0026#34;); print_list(head_p); print_array(head_p); printf(\u0026#34;\\n***** the second polynomials of one indeterminate *****\\n\u0026#34;); print_list(head_q); print_array(head_q); print_stack(); add(); printf(\u0026#34;\\n***** the sum polynomials of one indeterminate *****\\n\u0026#34;); print_list(head_sum); print_array(head_sum); print_stack(); return 0; } Xcode运行结果 input: 4 1 3 4 2 5 2 -3 0 2 -1 output: ***** the first polynomials of one indeterminate ***** 2x^3+4x^2+3x+1 index\tdata\thighpower\tnext 29\t2\t3\t12 12\t4\t2\t2 2\t3\t1\t14 14\t1\t0\t-1 ***** the second polynomials of one indeterminate ***** -1x^4+2x^3-3x+2 index\tdata\thighpower\tnext 5\t-1\t4\t19 19\t2\t3\t10 10\t-3\t1\t28 28\t2\t0\t-1 Stack(from bottom to top):7 24 9 20 16 22 0 18 27 1 23 25 6 13 3 8 21 17 4 11 15 26 ***** the sum polynomials of one indeterminate ***** -1x^4+4x^3+4x^2+3 index\tdata\thighpower\tnext 26\t-1\t4\t5 5\t4\t3\t19 19\t4\t2\t12 12\t3\t0\t-1 Stack(from bottom to top):7 24 9 20 16 22 0 18 27 1 23 25 6 13 3 8 21 17 4 11 15 29 2 10 14 28 Program ended with exit code: 0 ","date":"2020-10-13T00:00:00Z","image":"https://hungyam.gitee.io/code/p/polynomials-of-one-indeterminate/1_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://hungyam.gitee.io/code/p/polynomials-of-one-indeterminate/","title":"Polynomials of one indeterminate"}]